---
title: ‚ö° JS Prototypes & this Binding
---

### üîπ 1. What are Prototypes?

- In Javascript:
  - Every object has a hidden property called `[[Prototype]]` which can be accessed using `_proto_`
  - When you access a property on an object, JS looks:
    - 1. In the object itself.
    - 2. If not found, it **delegates to its prototype chain**.
  - Eg:
    ```
        const person = {name: "Sonam"}
        console.log(person.toString())     // [object object]
    ```
  - ‚úÖ `toString` is not defined in person, but JS finds it in `Object.prototype`.

### üîπ Prototype Inheritance

```
    function Person (name){
        this.name = name
    }

    Person.prototype.sayHello = function (){
        return `Hello from : ${this.name}`
    }

    const user = new Person('Sonam')
    console.log(user.sayHello())
```

- ‚úÖ `sayHello` is not copied to each object ‚Äî it‚Äôs stored in prototype and shared.

### üëâ Interview One-liner

_‚ÄúPrototypes allow objects to share methods without duplicating them in memory.‚Äù_

### üîπ 2. `this` Binding

- `this` depends on **how a function is called** ,not where it's defined.
- Eg:

```
    Case 1: Global Scope
    console.log(this)   // In browser ‚Üí window, in Node ‚Üí {}

    Case 2 : Inside a method
    const obj = {
        a: 10,
        getData: (){
            console.log(this.a)
        }
    }
    obj.getData()   // 10

    ‚úÖ this refers to the object calling the method (obj).

    Case 3: Lost this (Common Pitfall)
    const obj = {
        a: 10,
        getData: (){
            console.log(this.a)
        }
    }
    const fn = obj.getData
    fn();                   // undefined (in strict mode)

    ‚úÖ Because now fn is just a function, not called on obj.

    Case 4: this in Arrow Functions
    const obj = {
        name: "Sonam",
        greet: () => {
            console.log(this.name);
        }
    };
    obj.greet(); // ‚ùå undefined

    ‚úÖ Arrow functions do not bind their own this.
    They inherit this from the lexical scope (where they were created).
```

### ‚ö° `function` vs `arrow function` ‚Üí `this` Behavior

| Aspect                                          | **Regular Function (`function`)**                     | **Arrow Function (`=>`)**                                                                        |
| ----------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **Own `this`?**                                 | ‚úÖ Yes, `this` depends on how the function is called. | ‚ùå No, arrow functions do **not** bind `this`; they use `this` from the enclosing lexical scope. |
| **Default `this` in global scope (non-strict)** | `window` (in browsers)                                | `window` (same as lexical scope)                                                                 |
| **Default `this` in strict mode**               | `undefined`                                           | Inherits from enclosing scope                                                                    |
| **Inside an object method**                     | Refers to the object that called it                   | ‚ùå Refers to outer scope (usually `window`/`undefined`)                                          |
| **In a class method**                           | Refers to the instance                                | ‚ùå Still lexical `this` (not the instance unless wrapped)                                        |
| **Can use `bind` / `call` / `apply`?**          | ‚úÖ Yes                                                | ‚ùå No effect ‚Äî arrow functions ignore binding                                                    |
| **Best use case**                               | Object methods, class methods, dynamic `this`         | Callbacks, promises, event listeners (when you want to inherit surrounding `this`)               |

### üß† Interview One-liner

- **Regular function** ‚Üí this is dynamic (depends on call).
- **Arrow function** ‚Üí this is lexical (depends on where defined).

### üß† Quick Interview Takeaways

- Prototype ‚Üí Object inheritance mechanism.
- `this` ‚Üí Value depends on call site, not definition.
- Arrow functions ‚Üí no own `this`, use lexical scope.
- `bind/call/apply` ‚Üí Explicitly control `this`.
