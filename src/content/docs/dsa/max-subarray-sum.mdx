---
title: Maximum Subarray Sum
---

### ðŸŽ® Maximum Subarray = â€œThe Treasure Journeyâ€

- Imagine, you're a traveller walking on a path of **villages**.
- Each village has **gold (positive number)** or **bandits who rob you (negative number)**.
- Your goal:
  - ðŸ‘‰ Find the stretch of **consecutive villages** where your net gold is **maximized**.
- The Journey:

```
// Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
// Think: [ðŸ˜¢, ðŸ˜Š, ðŸ˜”, ðŸ˜„, ðŸ˜, ðŸ˜Š, ðŸ˜Š, ðŸ˜­, ðŸ˜Š]
```

### Key Points:

- **Contiguous:** Elements must be next to each other (no skipping!)
- **Subarray:** Can be the entire array, a portion, or even a single element
- **Maximum Sum:** We want the biggest possible total

### The Naive/Brute Force Approach ðŸŒ

_"Check every possible combination like a paranoid accountant"_

```
    const maxSubarrayNaive = (nums) => {
        let maxSum = nums[0]

        // Check every possible starting position
        for(let i =0; i<nums.length; i++){
            let currSum = nums[i]

            // Check every possible ending position from i
            for(j = i; j<nums.length; j++){
                currentSum += nums[j]
                maxSum = Math.max(maxSum, currentSum)
            }
        }
        return maxSum
    }
```

### How the journey works (Kadaneâ€™s rule):

- You keep a bag of gold (`currSum` = current streak)
- If your bag becomes negative (bandits took more than you have), ðŸ’¡ Drop it on the ground(reset to 0),
  because carrying debt will only hurt the next stretch.
- You also keep track of your best gold so far (`maxSum`/`best`)
- Example:
  ```
    Villages: [4, -1, 2, 1, -5, 4]
    Start: Village 1 gives +4 gold â†’ bag = 4 â†’ best = 4
    Village 2 robs -1 â†’ bag = 3 â†’ best = 4
    Village 3 gives +2 â†’ bag = 5 â†’ best = 5
    Village 4 gives +1 â†’ bag = 6 â†’ best = 6 ðŸ†
    Village 5 robs -5 â†’ bag = 1 â†’ best still 6
    Village 6 gives +4 â†’ bag = 5 â†’ best still 6
  ```
- ðŸ‘‰ Best journey = [4, -1, 2, 1] with 6 gold.

### Why this works (the mental hook âš¡ï¸)

- If your bag is **negative**, you're better off **dropping it** and starting fresh.
- Otherwise, **keep extending**.
- Always compare with **best stash ever found**.

### The Actual Code (Your Masterpiece-> Kadaneâ€™s Algorithm) ðŸŽ¨

```
    const maxSubarray(nums){
        let curr = nums[0]
        let best = nums[0]
        for(let i=1; i<nums.length;i++){
            const x = nums[i]
            curr = Math.max(curr, x + curr)
            best = Math.max(best, curr)
        }
        return best
    }
```

### Test Drive ðŸš—

```
    // Array: [-2,1,-3,4,-1,2,1,-5,4]

    // Step by step:
    // i=0: maxSum=-2, currentSum=-2
    // i=1: currentSum=max(1, -2+1)=1, maxSum=max(-2,1)=1
    // i=2: currentSum=max(-3, 1-3)=-2, maxSum=max(1,-2)=1
    // i=3: currentSum=max(4, -2+4)=4, maxSum=max(1,4)=4
    // i=4: currentSum=max(-1, 4-1)=3, maxSum=max(4,3)=4
    // i=5: currentSum=max(2, 3+2)=5, maxSum=max(4,5)=5
    // i=6: currentSum=max(1, 5+1)=6, maxSum=max(5,6)=6 ðŸŽ¯
    // i=7: currentSum=max(-5, 6-5)=1, maxSum=max(6,1)=6
    // i=8: currentSum=max(4, 1+4)=5, maxSum=max(6,5)=6

    // Result: 6 (subarray [4,-1,2,1])
```

### Complexity Comparison ðŸ“Š

| **Approach** | **Time** | **Space** | **Philosophy**            |
| ------------ | -------- | --------- | ------------------------- |
| Naive        | O(nÂ²)    | O(1)      | "Check everything!" ðŸ”    |
| Kadaneâ€™s     | O(n)     | O(1)      | "Learn from the past!" ðŸ§  |

_**The Winner: Kadane's Algorithm! ðŸ†**_

### Fun way to remember ðŸ§ 

- _"Keep the treasure streak alive if positive, drop it if it turns into debt, always keep track of the richest journey."_
- _"The key insight: Sometimes the best decision is to start fresh rather than dragging past baggage! âœ¨ðŸŽ­"_
